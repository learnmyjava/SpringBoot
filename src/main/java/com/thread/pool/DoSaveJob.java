package com.thread.pool;

/**
 * @author li_hhui
 * @date:2019年4月15日
 * @version:
 * 新建，就绪，运行，阻塞，死亡
 * 新建:new 创建后，jvm 为其实例分配内存，和其他java实例一样，无任何线程的动态特征
 * 就绪:调用start() ,jvm为其分配调用栈和计数器，让程序处于可运行状态，何时被调用取决于jvm线程调度器的调用
 * 运行:如果处于就绪状态下的线程获得了cpu,即刻开始run方法，即处于运行状态
 * 阻塞:运行中的程序，发生以下情况会进入阻塞状态:
 *    1.线程调用sleep()即主动放弃所占有的资源
 *    2.线程调用了一个阻塞式的I/O方法，在改方法返回前，该线程进入阻塞
 *    3.线程视图获得一个同步监控器，但该同步监控器正在被其他线程锁持有，
 *    4.线程在等待某个通知notify
 * 当线程进入阻塞状态，其他线程就可以获得可执行的机会，该阻塞的线程会在合适的时机重新进入就绪即可运行状态，等待jvm的调度
 * 针对上面的几种情况，当发生如下特定的情况将可以解除上面的阻塞，让该线程重新进入就绪状态：
	调用sleep方法的线程经过了指定时间。
	线程调用的阻塞式IO方法已经返回。
	线程成功地获得了试图取得同步监视器。
	线程正在等待某个通知时，其他线程发出了一个通知。
	处于挂起状态的线程被调用了resume恢复方法。
	
  死亡：run()方法执行完成，线程正常接收
  线程抛出一个未捕获的异常exception 或error
  
  
 * 	
 */
public class DoSaveJob implements Runnable{

	public DoSaveJob(int i){
		System.out.println("第"+i+"个线程被创建，");
	}
	@Override
	public void run() {
		
		System.out.println("线程获得资源去处理任务了");
	}

	
}
